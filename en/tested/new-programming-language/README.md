---
title: "Adding new programming languages"
description: "Configuring a new programming language in TESTed"
---

# Adding new programming languages

TESTed is extensible with new programming languages.
It is designed around a common core,
that implements the bulk of the functionality required by a software test framework in a generic way.
This core calls an internal API whenever it needs functionality that depends on a specific programming language.
All programming languages supported by TESTed have a language module that implements this internal API.

This tutorial explains in detail how a language module can implement the internal API for a new programming language,
essentially extending TESTed with support for the new programming language.
We will use the C programming language as an example
but indicate explicitly where we make configurations that are specific for the C programming language.
As such, you can follow this tutorial to extend TESTed with support for other programming languages.

Some useful links that can help you:

- Implementations of modules for all programming languages currently supported by TESTed, including the C module that is
  used as an example in this tutorial: <https://github.com/dodona-edu/universal-judge/tree/master/tested/languages>.
- Test exercises: <https://github.com/dodona-edu/universal-judge/tree/master/exercise>

## Installing and running TESTed

Because support for programming languages is added to TESTed itself,
running and testing TESTed will be essential during development of language modules.
You therefore need to install TESTed locally.
We recommend following the instructions from
the [README](https://github.com/dodona-edu/universal-judge#installing-tested) in the GitHub repository of TESTed.
Note that you only need to install the Python dependencies.
Dependencies for other programming languages (e.g. `ghc` for Haskell) are optional.

To follow the parts of this tutorial that focus on the C programming language,
you also need to have a local installation of the `gcc` compiler (version 8.1 or up).

::: tip Windows users
We recommend using the [Windows Subsystem for Linux](https://learn.microsoft.com/en-us/windows/wsl/) for development on Windows machines.
While TESTed is itself written in Python and thus platform independent,
dependencies for programming languages are not always available on Windows for each language.
:::

### Running TESTed

After cloning the GitHub repository of TESTed and installing the necessary dependencies,
the directory in which TESTed is installed should look like this:

```
universal-judge
├── exercise/     # Test exercises
├── tested/       # Sources
├── tests/        # Tests
├── workdir/      # Working directory when manually running TESTed
├── config.json   # Used in Dodona
└── run           # Used in Dodona
```

In this tutorial, we assume you run the commands in the root directory of the repository.
Test if you can run TESTed using the following command:

```shell
> python -m tested --help
usage: __main__.py [-h] [-c CONFIG] [-o OUTPUT] [-v]

The programming language agnostic educational test framework.

optional arguments:
  -h, --help            show this help message and exit
  -c CONFIG, --config CONFIG
                        Where to read the config from
  -o OUTPUT, --output OUTPUT
                        Where the judge output should be written to.
  -v, --verbose         Include verbose logs. It is recommended to also use -o in this case.
```

The above command is how you run TESTed in production.
For development, however, the need to always specify an exercise configuration is somewhat cumbersome.
For that purpose, you can run TESTed in development mode which uses a hard-coded configuration:

```shell
> python -m tested.manual
```

Running TESTed in development mode uses the hard-coded values defined in `tested/manual.py` to evaluate an exercise
and puts all files that are generated intermediately into the `workdir` directory of TESTed.
The latter can be very useful, for example, to inspect the test code that is generated by a language module.
If the `workdir` directory does not exist yet, you might need to create it.

## Design choices

Extending TESTed with support for a new programming language comes down
to implementing the internal API in a language module for that programming language.
In theory, implementing such a language module is nothing more than creating one subclass.
But we recommend the following structure:

1. A configuration file that contains some specific options for the programming language.
   This also includes the type configuration, which specifies the data type support for the programming language.
2. A configuration class that has some more dynamic options, such as the compilation command used when evaluating
   submissions.
3. Templates that are used to generate test code.

TESTed contains a utility that generates stubs for these files in the correct location.
Based on your answers to a few questions, stubs will be generated for a configuration file, a configuration class and
the templates. Run the utility using the following command:

```shell
> python -m tested.generation
```

Note that this command will only generate stub files for a new programming language.
It will not modify core TESTed files, so you should not forget to register the new language in TESTed later 
(see [_Registration_](#register-the-language)).

We will now look at the steps you need to take to add support for the C programming language to TESTed.
We assume the generation tool was not used, so in each step we will manually create the files.
If you did use the generation tool, skip the parts where the files are created.

## The C programming language

Before starting to add support for C, we first look briefly into what features of C we want to support:
what language features can we support in TESTed and what TESTed features can we support in C?

Of course, we want to support as much of the TESTed features as possible.
However, there are some limitations, especially in regard to data type support.

### Unsupported basic types

In the C language module, we will not support the following basic types:

- `sequence`:
  Arrays in C are special, compared to other programming languages.
  Static arrays cannot be used as a return value, and are not ideal as function parameters either.
  On the other hand, effectively using a dynamic array requires a pointer to the data and the size of the array.
  This has implications: for example, you need to pass two parameters if you want to pass an array to a function.
  TESTed currently has no support to pass literal values through multiple parameters,
  so sequences are currently not supported for the C programming language.
  Arrays as return values could be possible by using a struct that wraps the pointer and its size.
  However, this is non-standard and thus not supported at the moment.
- `set`: C does not have built-in sets.
- `map`: C does not have built-in maps.
  C has structs, but it is not possible to get access to their field names at runtime,
  so there is no way to serialize them.

### Unsupported advanced types

Obviously, the C language module will not support any advanced type that has an unsupported basic type.
In addition, the C language module will also not support the following advanced types:

- `bigint`: C does not have built-in arbitrary precision integers.
- `fixed_precision`: C does not have built-in fixed precision real numbers.

The first step is to create a directory for the configuration code of the C language module.
This directory must be named after the programming language
and created as a subdirectory of the `tested/languages` directory.
Create a new directory `tested/languages/c`:

```
universal-judge/
├─ tested/
│ ├─ languages/
│ │ ├── c/        <- new folder
│ │ ├── haskell/
│ │ ├── java/
│ │ ├── python/
│ │ ├── config.py
│ │ ...
│ ...
...
```

## Configuration file

A configuration file for a programming language in TESTed is a JSON file
configuring some static properties of the language.
Technically, this file is optional: you only need to implement the configuration class,
which we will do in [_Configuration class_](#configuration-class).
However, using a configuration file makes the implementation of the configuration class much easier.
Create a configuration file `tested/languages/c/config.json` (however, you probably want to remove the comments, as
those are not support by JSON):

```json5
{
 // General options about the language.
 "general": {
  // Files which will be available in the compilation and execution step.
  // We'll discuss these later, but these are dependencies that are needed
  // during the compilation step in C.
  "dependencies": [
   "values.h",
   "values.c",
   "evaluation_result.h",
   "evaluation_result.c"
  ],
  // If the language uses a selector during compilation.
  // This is true for most languages, including C.  
  "selector": true
 },
 "extensions": {
  // Extension of the generated test code.  
  "file": "c",
  // Extensions of the templates.
  // Defaults to the file extension and mako.
  "templates": [
   "c",
   "mako"
  ]
  // The default value, so not really necessary.
 },
 // Language constructs are translated into the style of the programming language
 "naming_conventions": {
  // Possibilities are snake_case, camelCase and PascalCase
  "namespace": "snake_case",
  // snake_case is the default
  "function": "snake_case"
 },
 // Indicate for which language constructs recognized by TESTed
 // we want to add support.
 // By default, all constructs are false, meaning no support.
 "constructs": {
  // Object-oriented stuff, such as classes and constructors.
  "objects": false,
  // Throwable exceptions.
  "exceptions": false,
  // Functions
  "function_calls": true,
  // Assignments (often a variable)
  // However, e.g. in Haskell this is implemented as a constant function
  // returning the same value. So, it is a "conceptual" assignment, not
  // necessarily a real one.
  // For example, `x = 5` is technically a function in Haskell, but is
  // considered an assignment in TESTed.
  "assignments": true,
  // If collections (e.g. lists) can have elements of different types.
  // For example, there is support in Python; it is difficult 
  // in Java and Haskell does not support it at all.
  "heterogeneous_collections": false,
  // If a function can accept arguments of different types.
  // For example, Java supports this with method overloading.
  // On the other hand, C does not support this.
  // An example is `echo("string")` and `echo(5)`.
  "heterogeneous_arguments": false,
  // If programmed checks are supported in this language.
  // Technically, not a language construct.
  "evaluation": false,
  // If named function arguments are supported.
  // This implies the arguments can be passed in a different order.
  // For example, Python supports this.
  "named_arguments": false,
  // If default values for function arguments are supported.
  "default_parameters": false
 },
 // Indicate which datatypes are supported in this language.
 // By default, all basic types are supported, but advanced types are not.
 // There are three possible values:
 // - supported: full support
 // - unsupported: no support
 // - reduced: only for advanced types. This indicates that the type will
 //   be reduced to its basic type. E.g. a list will become a sequence.
 "datatypes": {
  // BASIC TYPES
  "integer": "supported",
  "rational": "supported",
  "char": "supported",
  "text": "supported",
  "boolean": "supported",
  "sequence": "unsupported",
  // ADVANCED TYPES
  "set": "unsupported",
  "map": "unsupported",
  "nothing": "supported",
  "int8": "supported",
  "uint8": "supported",
  "int16": "supported",
  "uint16": "supported",
  "int32": "supported",
  "uint32": "supported",
  "int64": "supported",
  "uint64": "supported",
  "bigint": "unsupported",
  "single_precision": "supported",
  "double_precision": "supported",
  "double_extended": "supported",
  "fixed_precision": "unsupported",
  "array": "unsupported",
  "list": "unsupported",
  "tuple": "unsupported"
 },
 // Indicate limits on data structures.
 // For example, some languages have limits on the possible types for keys
 // in map-like data structures.
 // For example, maps are implemented using Objects in JavaScript, which means
 // that not all types are usable as keys.
 // This is an advanced configuration. We recommend leaving it until later.
 // For C, the list is empty, since C does not support either data structure.
 "restrictions": {
  "map_key": [],
  "set": []
 }
}
```

## Language-specific names for data types

::: warning Experimental
Currently,
configuration of language-specific names for data types is an experimental feature of TESTed and thus optional.
:::

TESTed supports describing problem statements in a generic way,
using a templating system
in which placeholders will be replaced by text that depends on a specific programming language.
One aspect of this process is
that the same data type might be known under different names in different programming languages.
For this purpose, create a type configuration file `tested/languages/c/types.json`.
See the different files for the different programming languages for examples.
Note that this feature of TESTed is still experimental, so future changes are possible.

## Configuration class

A configuration class is the only mandatory part of extending TESTed with support for a programming language.
It implements the internal API that TESTed uses as an interface between the core module and a language module.
Because the core module of TESTed is implemented in Python,
a configuration class needs to be implemented in Python as well.

Create a Python module `tested/languages/c/config.py` and define a class that inherits from `Language`:

```python
class C(Language):
    # See the docs of the parent class for all available options.
    # Most of the default implementations fall back to using the JSON
    # configuration file, but you could also override them all and not
    # use the configuration file.

    # The compilation command used by TESTed.
    # See below for more information, or check the method documentation
    # for technical details.
    def compilation(self, config: Config, files: List[str]) -> CallbackResult:
        main_file = files[-1]
        exec_file = Path(main_file).stem
        result = executable_name(exec_file)
        return (["gcc", "-std=c11", "-Wall", "evaluation_result.c", "values.c",
                 main_file, "-o", result], [result])

    # Execution command used by TESTed.
    # This will execute the result of the compilation command.
    # See below for more information, or check the method documentation
    # for technical details.
    def execution(self, config: Config,
                  cwd: Path, file: str, arguments: List[str]) -> Command:
        local_file = cwd / executable_name(Path(file).stem)
        return [str(local_file.absolute()), *arguments]

    def solution(self, solution: Path, bundle: Bundle):
        # Contains some code to change the main function.
        # See the actual implementation for the details.
        pass
```

### Compilation

::: tip Interpreted languages
Whenever possible, we recommend adding a compilation step even for languages that are interpreted and not compiled.
For example, the compilation steps for Python and JavaScript check that submissions have no syntax errors.
However, if the programming language does not support relevant static code analysis prior to execution (e.g. Bash),
you can skip this part of the configuration class.
The default implementation skips the compilation step.
:::

The first parameter of the `compilation` method takes a class with some configuration options,
including all [exercise options](/en/tested/exercise-config).
For example, you could allow the exercise designer to choose what C version is used by TESTed (e.g. C99 instead of C11).
However, the current implementation of the C language module only supports C11.

The second parameter of the `compilation` method takes a list of files that TESTed deems useful to have during
compilation,
including all dependencies specified in the configuration file,
the submission and files containing the generated test code.
By convention, the last file in the list contains the `main` function and should thus be the file being compiled.
All files will be in the same directory as the main file.
The compilation method does not need to use all files.
In case of the C programming language, for example, `gcc` takes care of loading all other files,
so we only use the main file.
As is done in the C language module,
you can also hardcode the names of files defined as dependencies in the configuration file.

The compilation method must return a tuple with two elements: i) the compilation command and ii) the resulting files or
file filter.
TESTed uses the Python module `subprocess` to execute the compilation command.
The resulting list of files or file filter is used to copy the compiled executable to the execution directory.
Only the compiled executable will be available during execution.

You can return a list of files if the compilation process results in executable files with predictable names.
For example, in C we know the name of the resulting binary, so we just return a list containing that name.
When returning a list of files, you should also follow the convention that the main file is at the end of the list.

However, it is not always possible to predict the list of executables.
In Java, for example, compiling a `.java` file will result in one or more `.class` files,
depending on the content of the `.java` file.
In that case, you can return a filter function that determines what executable files must be copied.
After compilation, TESTed will call the filter function for each file in the compilation directory.

Here's an example of calling the compilation method with the arguments and return values for C (on Windows):

```python
>>> compilation(['submission.c', 'evaluation_result.c', 'context_0_0.c', 'selector.c'])
(
    ['gcc', '-std=c11', '-Wall', 'evaluation_result.c', 'values.c', 'selector.c',
     '-o', 'selector.exe'], ['selector.exe']
)
```

Return an empty list as the compilation command to skip compilation.

### Execution

After compiling the submission and the test code,
TESTed must execute the test code to get the results that must be evaluated.
This is done by calling the `execution` method, which has four parameters:

- `config`: Same purpose as the first parameter of the `compilation` method.
  For example, the Java implementation uses this parameter to set the maximum JVM memory.
- `cwd`: Path name of the directory in which execution is taking place.
- `file`: Name of the file that must be executed.
- `arguments`: Arguments passed to the execution process. These are used, for example, to select what context TESTed must execute.

The `execution` method must return the execution command.
TESTed again uses the Python module `subprocess` to execute the execution command.
For the C programming language, TESTed simply executes the executable file with the given arguments. Here's an example of calling the execution method with the arguments and return values for C (on Windows):


```python
>>> execution('/test/path', 'executable.exe', ['arg1', 'arg2'])
['/test/path/executable.exe', 'arg1', 'arg2']
```

For most languages, this ends the configuration process.
However, the C programming language has the restriction that executables can only have a single `main` function.
This gives a possible conflict because the submission can have a `main` function and the generated test code also has a `main` function.
To resolve this conflict, we can use the submission method to modify the code of the submission by renaming the main function.
See the [actual implementation](https://github.com/dodona-edu/universal-judge/blob/2cd131a5f34de93d6a68d4234fb0b595f28285d9/tested/languages/c/config.py#L87) on GitHub.

## Templates

As a last step, we need to implement some templates TESTed will use to generate test code and to translate the test suite into the programming language of the submission.

Some templates are somewhat mandatory because they are used by the default implementation of the configuration class,
but it is often useful to create a few more templates to enable reuse.
For the C language module, we create the following templates:

- `run.c`: template to execute multiple contexts together (**mandatory**)
- `selector.c`: template to select what context to execute when using batch compilation (mandatory if batch compilation is supported) (**mandatory** if batch compilation is supported)
- `declaration.mako`: translates a variable declaration to C
- `function.mako`: translates a function call to C
- `statement.mako`: translates a TESTed statement (including expressions) to C (**mandatory**)
- `value.mako`: translates a literal value to C; makes use of two helper templates: `value_arguments.mako` and `value_basic.mako`

All templates are located in `tested/languages/c/templates`.

### Run template

The run template is conceptually the most complex template.
It is responsible for generating the test code for a single run.

::: tip Runs in TESTed
Conceptually, TESTed will execute test code for each individual context to make sure that contexts are evaluated in isolation.
However, this means launching a new execution process for each individual context, which may introduce a lot of overhead.
As such, TESTed may combine multiple contexts in a single run, essentially executing all these contexts in a single process.
In that case, care should be taken that successive contexts do not interfere with each other.
:::

::: tip White space in Mako
TESTed uses the Mako templating system for its templates.
The default configuration of Mako in TESTed will strip Mako-induced white space.
For example, the `for`-loop below will not be indented in the test code:

```c
% for name in evaluator_names:
    #include "${name}.c"
% endfor
```

Will result in 

```c
#include "name1.c"
```

Newlines in a template file will result in newlines in the test code.
This can be suppressed by using a backslash to escape the newline:

```c
int test = \⏎
"test";⏎
```

Will result in:

```c
int test = "test";⏎
```

:::

Here's the annotated implementation of the run template in the C language module:


```c
#include <stdio.h>

// Include the values module, responsible for serialisation.
#include "values.h"
// Include the submission code.
#include "${submission_name}.c"

// Import all programming language-specific checks.
% for name in evaluator_names:
    #include "${name}.c"
% endfor

// Create the variables which will contain the names of the files used to
// save the return values and the exceptions.
// C doesn't support exceptions, but TESTed still requires the file to be present.
// We also define two functions to write a separator to the file.
// These will be used between each context and each test case,
// allowing TESTed to separate the results in the output files.
static FILE* ${execution_name}_value_file = NULL;
static FILE* ${execution_name}_exception_file = NULL;

static void ${execution_name}_write_separator() {
    fprintf(${execution_name}_value_file, "--${secret_id}-- SEP");
    fprintf(${execution_name}_exception_file, "--${secret_id}-- SEP");
    fprintf(stdout, "--${secret_id}-- SEP");
    fprintf(stderr, "--${secret_id}-- SEP");
}

static void ${execution_name}_write_context_separator() {
    fprintf(${execution_name}_value_file, "--${context_secret_id}-- SEP");
    fprintf(${execution_name}_exception_file, "--${context_secret_id}-- SEP");
    fprintf(stdout, "--${context_secret_id}-- SEP");
    fprintf(stderr, "--${context_secret_id}-- SEP");
}

// ... continues in the next code block
```

If a function or method call returns a value, TESTed must serialize the value before writing it to an output file.
This serialization converts the representation of the value in a programming language into the language-independent format used by TESTed.
It is useful to implement data serialization as a separate module, which is called "values" by convention.
TESTed expects an implementation of the following functions:

- `send_value(value)`: Serializes and writes a value to the return output file.
- `send_exception(exception)`: Serializes and writes an exception to the exception output file.
- `send_specific_value(value)`: Serializes and writes the result of a check for a specific programming language to the return channel.
- `send_specific_exception(exception)`: Serializes and writes the result of a check for a specific programming language to the exception channel.

As the C programming language does not support exceptions, we implement the two exception functions. The two return functions are implemented using a macro:


```c
// ... continuation of the previous code block

// Uses the function from the values module.
#undef send_value
#define send_value(value) write_value(${execution_name}_value_file, value)

#undef send_specific_value
#define send_specific_value(value) write_evaluated(${execution_name}_value_file, value)

// ... continues in the next code block
```

Finally, we execute the contexts by generating test code that defines one function per context:

```c
// ... continuation of the previous code block

// Generate a function for each context in this run:
% for i, ctx in enumerate(contexts):
    void ${execution_name}_context_${i}(void) {
        // Optional code fragment before executing a context.
        ${ctx.before}
        // Execute each test case.
        % for testcase in ctx.testcases:
            // Write the separator to the output files.
            ${execution_name}_write_separator();
            // Use another template to generate the statement that must be executed.
            <%include file="statement.mako" args="statement=testcase.input_statement()" />;
        % endfor
        // Optional code fragment after executing a context.
        ${ctx.after}
    }
% endfor

... continued after the text block
```
Now, we must still generate the test code that will call these context functions:

```c
// Generate a function that will execute the run.
int ${execution_name}() {
    
    // Create the output files.
    ${execution_name}_value_file = fopen("${value_file}", "w");
    ${execution_name}_exception_file = fopen("${exception_file}", "w");

    // Similarly to the separator for test cases, we write the context
    // separator between each execution of a context.
    ${execution_name}_write_context_separator();
    
    // This is a special test case: it is used when you want to test
    // the main function of the submission.
    % if run_testcase.exists:
        char* args[] = {\
        % for argument in ["solution"] + run_testcase.arguments:
            "${argument}", \
        % endfor
        };
        int exit_code = solution_main(${len(run_testcase.arguments) + 1}, args);
        if (exit_code != 0) {
            return exit_code;
        }
    % endif

    // Execute all contexts from the test suite.
    % for i, ctx in enumerate(contexts):
        // Don't forget the separator.
        ${execution_name}_write_context_separator();
        // Call the function we generated previously.
        ${execution_name}_context_${i}();
    % endfor

    // We are done, so close the result files.
    fclose(${execution_name}_value_file);
    fclose(${execution_name}_exception_file);
    return 0;
}

// TESTed also supports batch compilation, in which case
// we don't need a main function. Otherwise we do.
// In batch compilation the main is not needed, since this
// module will be called from the selector module.
#ifndef INCLUDED
int main() {
    return ${execution_name}();
}
#endif
```

### Selector template

In batch compilation, TESTed uses the selector template to select what context is executed.
We set `INCLUDED` to `true`, as this will allow us to include the above run template:

```c
#include <string.h>
#include <stdio.h>

#define INCLUDED true

% for cont in contexts:
    // Include individual context files.
    // This is the same code as in the file before.
    // We will probably merge these in the future.
    #include "${cont}.c"
% endfor

// Main function.
int main(int argc, const char* argv[]) {

    if (argc < 1) {
        fprintf(stderr, "No run context selected.");
        return -2;
    }
    
    // Code to execute the correct context.
    const char* name = argv[1];
    % for cont in contexts:
        if (strcmp("${cont}", name) == 0) {
            return ${cont}();
        }
    % endfor
    fprintf(stderr, "Non-existing run context '%s' selected.", name);
    return -1;
}
```

### Statement template

TESTed uses the statement template to convert statements and expressions to the programming language of the submission.
This is how the C language module implements the statement template:

```c
## Convert a statement and/or expression into Java code.
<%! from tested.utils import get_args %>\
<%! from tested.serialisation import Value, Identifier, FunctionCall, Assignment %>\
<%page args="statement,full=False"/>\
% if isinstance(statement, Identifier):
    ## If the expression is an identifier, just echo it.
    ${statement}\
% elif isinstance(statement, FunctionCall):
    ## Delegate to the function template for function calls.
    <%include file="function.mako" args="function=statement"/>\
% elif isinstance(statement, get_args(Value)):
    ## We have a value, delegate to the value template.
    <%include file="value.mako", args="value=statement" />\
% else:
    <% assert isinstance(statement, get_args(Assignment)) %>\
    % if full:
        <%include file="declaration.mako" args="tp=statement.type, value=statement.expression" /> \
    % endif
    ${statement.variable} = <%include file="statement.mako" args="statement=statement.expression"/>\
% endif
```

One non-intuitive aspect is the parameter `full` that indicates whether a variable declaration is needed:

```c
int variabele = 5; // with declaration
variabele = 6; // without declaration
```

See the actual templates for examples of how to handle most language constructs.

## Register the language

We also need to register the language module in TESTed.
This must always be done manually, even if the generator is used to generate stubs.
In the file `tested/languages/__init__.py`, add the language to the dictionary `LANGUAGES`:

```python
LANGUAGES = {
    'c': C,  # This is what we added here, mapping a name to the configuration class.
    'haskell': Haskell,
    'java': Java,
    'javascript': JavaScript,
    'kotlin': Kotlin,
    'python': Python,
    'runhaskell': RunHaskell,
}
```

## Testing the language implementation

Now that we have configured and registered the language for TESTed,
we can test if the language implementation works as expected.
TESTed contains some predefined tests that can be used for that purpose.
Before this can be done, you should also extend the tests to support testing the new programming language:

1. Add solutions in the programming language to one or more of the test exercises (in the `exercise` directory). Take a look at the existing solutions to infer what your solutions should do.
2. Modify `tests/test_functionality.py` and other test files to include the new programming language for testing.
